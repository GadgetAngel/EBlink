/////////////////////////////////////////////////////////////////////////////////
//
//          STM32L4_fl 
//
//

const FLASH_BASE = 0x40022000

// Flash registers offsets 
const FLASH_ACR      =   0x00
const FLASH_KEYR     =   0x08
const FLASH_OPTKEYR  =   0x0c
const FLASH_SR       =   0x10
const FLASH_CR       =   0x14
const FLASH_OPTR     =   0x20
const FLASH_WRP1AR   =   0x2c
const FLASH_WRP1BR   =   0x30
const FLASH_WRP2AR   =   0x4c
const FLASH_WRP2BR   =   0x50



// FLASH_CR register bits 
const FLASH_CR_PG         =  (1 << 0)
const FLASH_CR_PER        =  (1 << 1)
const FLASH_CR_MER1       =  (1 << 2)
const FLASH_CR_PAGE_SHIFT =  3
const FLASH_CR_BKER       =  (1 << 11)
const FLASH_CR_MER2       =  (1 << 15)
const FLASH_CR_STRT       =  (1 << 16)
const FLASH_CR_OPTSTRT    =  (1 << 17)
const FLASH_CR_EOPIE      =  (1 << 24)
const FLASH_CR_ERRIE      =  (1 << 25)
const FLASH_CR_OBL_LAUNCH =  (1 << 27)
const FLASH_CR_OPTLOCK    =  (1 << 30)
const FLASH_CR_LOCK       =  (1 << 31)
 
// FLASH_SR register bits 
const FLASH_SR_BSY        =  (1 << 16)
const FLASH_SR_PGSERR     =  (1 << 7) // Programming sequence error
const FLASH_SR_SIZERR     =  (1 << 6) // Size error
const FLASH_SR_PGAERR     =  (1 << 5) // Programming alignment error
const FLASH_SR_WRPERR     =  (1 << 4) // Write protection error
const FLASH_SR_PROGERR    =  (1 << 3) // Programming error
const FLASH_SR_OPERR      =  (1 << 1) // Operation error
const FLASH_SR_EOP        =  (1 << 0) // End of operation


const FLASH_KEY1       = 0x45670123
const FLASH_KEY2       = 0xCDEF89AB

const MAX_FLASH_SPEED  = 10000   // 10MHz is max speed for direct programming (we think)

savedProbeSpeed <-0   // Our current probe speed 0= not checked, -1 = checked not changed, > 0 = original speed



/////////////////////////////////////////////////////////////////////////////////
//
//   Called by EBlink to initialize upcoming flash operations.
//   Unlock the flash and preload the flash loader
//
function flash_start()
{
    local targetApi = :: TargetAPI(); // Our interface to the target class
    local result;

    // Be sure that the core is halted
    result = targetApi.halt(); if(result<0) return result;

    // Unlock flash
    return flash_unlock(); if(result<0) return result;
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Called by EBlink to erase a sector
//   Erase sequence according ST user manual
//    - flash_start() is already called
//    - flash_done() will be called if all flash operations are ready
//
function flash_erase(sector, address)
{
    local result;
	local time;
	local eraseFlags = FLASH_CR_PER;
	
	// Check if we have bank 1
	if(sector > 255)
		eraseFlags  = eraseFlags | ( (256-sector)<< FLASH_CR_PAGE_SHIFT | FLASH_CR_BKER );
	else
	    eraseFlags  = eraseFlags | (sector<< FLASH_CR_PAGE_SHIFT );


    // (1) Set the PER bit and select the page you wish to erase (PNB) with the associated bank (BKER) in the 
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, eraseFlags ); if(result<0) return result;

    // (4) Set the STRT bit in the FLASH_CR register.
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, eraseFlags | FLASH_CR_STRT); if(result<0) return result;

    // (5) Wait until the BSY bit is reset in the FLASH_SR register
	time = GetTickCount();
    do{
	    // Check for time out
	    if(GetTickCount() - time > 1000)
        {
            errorf("Error: flash keeps busy\n");
            return -1;
        }
         result = itrfApi.readMem32(FLASH_BASE + FLASH_SR); if(result<0) return result;
    }while ( itrfApi.value32 & FLASH_SR_BSY);

    return ERROR_OK;
}



/////////////////////////////////////////////////////////////////////////////////
//
//  Called by EBlink to write a sector.
//  The length is always equals to the page to be programmed in bytes.
//  Only whole pages are programmed driven by the cache engine of this GDB server.
//
function flash_write(sector, address, buffer)
{
    local targetApi = :: TargetAPI(); // Our interface to the target class
    local result;
	local probeSpeed;

	// Did we already checked the current probe speed.
	// For direct flash writing we can't be too fast.
	if( savedProbeSpeed == 0)
	{
		probeSpeed = itrfApi.getSpeed();
		if(probeSpeed > MAX_FLASH_SPEED )
		{
			savedProbeSpeed = probeSpeed;
			itrfApi.setSpeed(MAX_FLASH_SPEED);
		}
		else
		{
		    // We checked and don't changed the probe speed
			savedProbeSpeed = -1;
		}
	}

    // Enable the program flag PG in flash_CR
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_PG ); if(result<0) return result;

	// Write buffer to flash with 32bit memory access
    result = itrfApi.writeBuf(address, buffer, 32);

	// Check if the current probe is supporting 16bits width memory access, if not then fall
	// back to external flash loader
	// Remark: This part can be replaced by user warning to update the STlink firmware. This is only here
	//         to support older STlink firmware versions not capable of 16bit memory access.
	if(result == INTERFACE_NOT_SUPPORTED)
	{
        errorf("This interface doesn't support direct 16bit memory access\nPlease update probe firmware or use other probe\n");
		return -1;
	}

    return result;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Called by EBlink if all flash operations are ready
//
function flash_done()
{
    // Restore the original probe speed if changed
	if(savedProbeSpeed > 0)
		itrfApi.setSpeed(savedProbeSpeed);

    // Relock the flash by setting the FLASH_CR_LOCK in the flash CR register
    return itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_LOCK );
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Unlock the flash
//
function flash_unlock()
{
    local result;

	result = itrfApi.readMem32(FLASH_BASE + FLASH_CR); if(result<0) return result;

	if(itrfApi.value32 & FLASH_CR_LOCK )
	{
		// Unlock Flash
		result = itrfApi.writeMem32(FLASH_BASE + FLASH_KEYR, FLASH_KEY1 ); if(result<0) return result;
		result = itrfApi.writeMem32(FLASH_BASE + FLASH_KEYR, FLASH_KEY2 ); if(result<0) return result;

		result = itrfApi.readMem32(FLASH_BASE + FLASH_CR); if(result<0) return result;
		if(itrfApi.value32 & FLASH_CR_LOCK )
		{
			errorf("Error: unlock flash failed!\n");
			return -1;
		}
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////////
//
//  Called by EBlink if chip erase is needed (e.g. command line flashing)
//
//   Erase the whole chip
//   - If this function is not defined, sector by sector erase is used by EBlink.
//   - This is an isolated function, flash_start and flash_done are not called by EBlink
//
function flash_erase_chip()
{
    local targetApi = :: TargetAPI(); // Our interface to the target class
    local result;
    local time;

    printf("Flash chip erase ");

	// Be sure that the target is halted
	result = targetApi.halt(); if(result<0) return result;

	// Unlock flash
	result = flash_unlock(); if(result<0) return result;

    // (1) Set the MER1 and MER2 bit in the FLASH_CR register to enable mass erasing
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_MER1  ); if(result<0) return result;

	// (2) Set the STRT bit in the FLASH_CR register to start the erasing
	    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_MER1 | FLASH_CR_STRT ); if(result<0) return result;

	// (3) Wait until the BSY bit is reset in the FLASH_SR register
	time = GetTickCount();
    do{
		CursorAnimate();

	    // Check for time out of 30 seconds
	    if(GetTickCount() - time > 3000)
        {
            errorf("Error: flash keeps busy\n");
            return -1;
        }
         result = itrfApi.readMem32(FLASH_BASE + FLASH_SR); if(result<0) return result;
    }while ( itrfApi.value32 & FLASH_SR_BSY);


    printf("done\n");

	// Lock the flash again
    return flash_done();
}

