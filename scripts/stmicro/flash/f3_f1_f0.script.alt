/////////////////////////////////////////////////////////////////////////////////
//
//          STM32HW_fl (Half word flash loader)
//
//  Remark: The external bootloader needs more ram space than one page size!!!
//
//  Alternative flash script for halfword flashing if the probe doesn't support direct
//  16bit mempry access. It uses an external bootloader to program the flash, however the
//  needed ram space for this bootloader is sometimes larger than available.
//
const FLASH_BASE = 0x40022000;

const FLASH_KEY  = 0x04;
const FLASH_SR   = 0x0C;
const FLASH_CR   = 0x10;
const FLASH_AR   = 0x14;

// Register flags
const FLASH_SR_BSY     = 0x01;
const FLASH_SR_PROGERR = 0x04;
const FLASH_SR_WRPERR  = 0x10;
const FLASH_SR_EOP     = 0x20;

const FLASH_CR_LOCK    = 0x80;
const FLASH_CR_STRT    = 0x40;

const FLASH_CR_MER     = 4;
const FLASH_CR_PER     = 2;
const FLASH_CR_PG      = 1;

const FLASH_KEY1       = 0x45670123;
const FLASH_KEY2       = 0xCDEF89AB;

const MAX_FLASH_SPEED  = 10000;  // 10MHz is max speed for direct programming (we think)

savedProbeSpeed <-0;  // Our current probe speed

/////////////////////////////////////////////////////////
// Half word external flash loader, parameters :
//  r0 = scratch area
//  r1 = start program address
//  r2 = Length in half words
//
const flashLoader = "\
\x01\x25\x04\x26\x08\x4C\x09\x4F\x03\x88\xBB\x42\x05\xD0\x0B\x80\
\xE3\x68\x2B\x42\xFC\xD1\x33\x42\x04\xD1\x02\x30\x02\x31\x01\x3A\
\x00\x2A\xF1\xD1\x00\xBE\xC0\x46\x00\x20\x02\x40\xFF\xFF\x00\x00";

const FLASH_LOAD_SIZE = 48;
const LOADER_ADDR     = 0x20000000;
const SCRATCH_ADDR    = 0x20000100;  // The area for program upload

/////////////////////////////////////////////////////////////////////////////////
//
//   Called by EBlink to initialize upcoming flash operations.
//   Unlock the flash and preload the flash loader
//
function flash_start()
{
    local targetApi = :: TargetAPI(); // Our interface to the target class
    local result;

    // Be sure that the core is halted
    result = targetApi.halt(); if(result<0) return result;

    // Unlock flash
    result = flash_unlock(); if(result<0) return result;


    // Load the flash loader in advance in target RAM in case we need it
    return itrfApi.loadString(LOADER_ADDR, flashLoader, FLASH_LOAD_SIZE);
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Called by EBlink to erase a sector
//   Erase sequence according ST user manual
//    - flash_start() is already called
//    - flash_done() will be called if all flash operations are ready
//
function flash_erase(sector, address)
{
    local result;
    local time;

    // (1) Set the PER bit in the FLASH_CR register to enable page erasing
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_PER ); if(result<0) return result;

    // (2) Program the FLASH_AR register to select a page to erase
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_AR, address ); if(result<0) return result;

    // (3) Set the STRT bit (keep PER set) in the FLASH_CR register to start the erasing
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR,  FLASH_CR_STRT| FLASH_CR_PER); if(result<0) return result;

    // (4) Wait until the BSY bit is reset in the FLASH_SR register
    time = GetTickCount();
    do{
        // Check for time out
        if(GetTickCount() - time > 1000)
        {
            errorf("Error: flash keeps busy\n");
            return -1;
        }
         result = itrfApi.readMem32(FLASH_BASE + FLASH_SR); if(result<0) return result;
    }while ( itrfApi.value32 & FLASH_SR_BSY);

    //  (5) Check the EOP flag in the FLASH_SR register
    if( (itrfApi.value32 & FLASH_SR_EOP) == 0)
    {
       errorf("ERROR: Failed erasing sector %d\n", sector);
       return -1;
    }

    // (6) Clear EOP flag by software by writing EOP at 1
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_SR, itrfApi.value32 | FLASH_SR_EOP); if(result<0) return result;

    // (7) Reset the PER Bit to disable the page erase
    return itrfApi.writeMem32(FLASH_BASE + FLASH_CR, 0 );
}



/////////////////////////////////////////////////////////////////////////////////
//
//  Called by EBlink to write a sector.
//  The length is always equals to the page to be programmed in bytes.
//  Only whole pages are programmed driven by the cache engine of this GDB server.
//
function flash_write(sector, address, buffer)
{
    local targetApi = :: TargetAPI(); // Our interface to the target class
    local result;
    local probeSpeed;

    // Did we already checked the current probe speed.
    // For direct flash writting we can't be too fast.
    if( savedProbeSpeed == 0)
    {
        probeSpeed = itrfApi.getSpeed();
        if(probeSpeed > MAX_FLASH_SPEED )
        {
            savedProbeSpeed = probeSpeed;
            itrfApi.setSpeed(MAX_FLASH_SPEED);
        }
        else
        {
            // We don't changed the probe speed
            savedProbeSpeed = -1;
        }
    }

    // Enable the program flag PG in flash_CR
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_PG ); if(result<0) return result;

    // Write buffer to flash with 16bit memory access
    result = itrfApi.writeBuf(address, buffer, 16);

    // Check if the current probe is supporting 16bits width memory access, if not then fall
    // back to external flash loader
    // Remark: This part can be replaced by user warning to update the STlink firmware. This is only here
    //         to support older STlink firmware versions not capable of 16bit memory access.
    if(result == INTERFACE_NOT_SUPPORTED)
    {
        // Restore the original probe speed if changed
        if(savedProbeSpeed > 0)
        {
            itrfApi.setSpeed(savedProbeSpeed);
            savedProbeSpeed = -1; // We don't have to do it again
        }

        // Write buffer to data ram space
        result = itrfApi.writeBuf(SCRATCH_ADDR, buffer, 32); if(result<0) return result;

        buffer.byteLength /= 2; // Half words (16bits) count used by the flash loader

        // Initialize flash loader
        result = targetApi.writeReg("R0", SCRATCH_ADDR);   // Data address to be written
        result = targetApi.writeReg("R1", address);        // Target address in flash
        result = targetApi.writeReg("R2", buffer.byteLength);   // Halfwords count to be written

        // Run flash loader
        result = targetApi.execute(LOADER_ADDR, true); if(result<0) return result;

        // Check flash loader result, if $R2 is 0 then all data is written
        result = targetApi.readReg("R2");
        if(targetApi.value32 != 0)
        {
            errorf("ERROR flashing sector: %d [0x%08X]", sector, address);
            return -1;
        }
    }

    return result;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Called by EBlink if all flash operations are ready
//
function flash_done()
{
    // Restore the original probe speed
    if(savedProbeSpeed > 0)
        itrfApi.setSpeed(savedProbeSpeed);

    // Relock the flash by setting the FLASH_CR_LOCK in the flash CR register
    return itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_LOCK );
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Unlock the flash
//
function flash_unlock()
{
    local result;

    result = itrfApi.readMem32(FLASH_BASE + FLASH_CR); if(result<0) return result;

    if(itrfApi.value32 & FLASH_CR_LOCK )
    {
        // Unlock Flash
        result = itrfApi.writeMem32(FLASH_BASE + FLASH_KEY, FLASH_KEY1 ); if(result<0) return result;
        result = itrfApi.writeMem32(FLASH_BASE + FLASH_KEY, FLASH_KEY2 ); if(result<0) return result;

        result = itrfApi.readMem32(FLASH_BASE + FLASH_CR); if(result<0) return result;
        if(itrfApi.value32 & FLASH_CR_LOCK )
        {
            errorf("Error: unlock flash failed!\n");
            return -1;
        }
    }
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////
//
//  Called by EBlink if chip erase is needed (e.g. command line flashing)
//
//   Erase the whole chip
//   - If this function is not defined, sector by sector erase is used by EBlink.
//   - This is an isolated function, flash_start and flash_done are not called by EBlink
//
function flash_erase_chip()
{
    local targetApi = :: TargetAPI(); // Our interface to the target class
    local result;
    local time;

    printf("Flash chip erase ");

    // Be sure that the target is halted
    result = targetApi.halt(); if(result<0) return result;

    // Unlock flash
    result = flash_unlock(); if(result<0) return result;

    // (1) Set the MER bit in the FLASH_CR register to enable mass erasing
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_MER ); if(result<0) return result;

    // (2) Set the STRT bit in the FLASH_CR register to start the erasing
        result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, FLASH_CR_MER | FLASH_CR_STRT ); if(result<0) return result;

    // (3) Wait until the BSY bit is reset in the FLASH_SR register
    time = GetTickCount();
    do{
        CursorAnimate();

        // Check for time out of 30 seconds
        if(GetTickCount() - time > 3000)
        {
            errorf("Error: flash keeps busy\n");
            return -1;
        }
         result = itrfApi.readMem32(FLASH_BASE + FLASH_SR); if(result<0) return result;
    }while ( itrfApi.value32 & FLASH_SR_BSY);

    // (4) Check the EOP flag in the FLASH_SR register
    if( (itrfApi.value32 & FLASH_SR_EOP) == 0)
    {
       errorf("ERROR: Failed erasing sector %d\n", sector);
       return -1;
    }

    // (5) Clear EOP flag by software by writing EOP at 1
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_SR, itrfApi.value32 | FLASH_SR_EOP); if(result<0) return result;

    // (6) Reset the PER Bit to disable the mass erase
    result = itrfApi.writeMem32(FLASH_BASE + FLASH_CR, 0 ); if(result<0) return result;

    printf("done\n");

    // Lock the flash again
    return flash_done();
}
