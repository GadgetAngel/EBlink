/////////////////////////////////////////////////////////////////////////////////
//
//                   STM32Lx_fl flash loader
//

// Global variable "FLASH_BASE" is defined in uppder device script

// stm32lx flash register locations 

const FLASH_ACR       0x00
const FLASH_PECR      0x04
const FLASH_PDKEYR    0x08
const FLASH_PEKEYR    0x0C
const FLASH_PRGKEYR   0x10
const FLASH_OPTKEYR   0x14
const FLASH_SR        0x18
const FLASH_OBR       0x1C
const FLASH_WRPR      0x20

// FLASH_PECR bits 
const FLASH_PECR__PELOCK      (1<<0)
const FLASH_PECR__PRGLOCK     (1<<1)
const FLASH_PECR__OPTLOCK     (1<<2)
const FLASH_PECR__PROG        (1<<3)
const FLASH_PECR__DATA        (1<<4)
const FLASH_PECR__FTDW        (1<<8)
const FLASH_PECR__ERASE       (1<<9)
const FLASH_PECR__FPRG        (1<<10)
const FLASH_PECR__EOPIE       (1<<16)
const FLASH_PECR__ERRIE       (1<<17)
const FLASH_PECR__OBL_LAUNCH  (1<<18)

// FLASH_SR bits 
const FLASH_SR__BSY       (1<<0)
const FLASH_SR__EOP       (1<<1)
const FLASH_SR__ENDHV     (1<<2)
const FLASH_SR__READY     (1<<3)
const FLASH_SR__WRPERR    (1<<8)
const FLASH_SR__PGAERR    (1<<9)
const FLASH_SR__SIZERR    (1<<10)
const FLASH_SR__OPTVERR   (1<<11)
const FLASH_SR__NOTZERO   (1<<16)

// Unlock keys 
const PEKEY1          0x89ABCDEF
const PEKEY2          0x02030405
const PRGKEY1         0x8C9DAEBF
const PRGKEY2         0x13141516
const OPTKEY1         0xFBEAD9C8
const OPTKEY2         0x24252627


const MAX_FLASH_SPEED  = 4000;  // 4MHz is max speed for direct programming (we think)

savedProbeSpeed <-0;  // Our current probe speed 0= not checked, -1 = checked not changed, > 0 = original speed


/////////////////////////////////////////////////////////////////////////////////
//
//   Unlock the flash
//
function flash_start()
{
    local targetApi = :: TargetAPI(); // Our interface to the target class
    local result;

    // Be sure that the core is halted
    result = targetApi.halt(); if(result<0) return result;

    // Read flash lock status
    result = itrfApi.readMem32(FLASH_BASE|FLASH_PECR); if(result<0) return result;

    // Check if it's locked by the FLASH_CR_LOCK flag
    if( itrfApi.value32 & (FLASH_PECR__PELOCK|FLASH_PECR__PRGLOCK) )
    {
        // Unlock
        result = itrfApi.writeMem32(FLASH_BASE|FLASH_PEKEYR,PEKEY1); if(result<0) return result;
        result = itrfApi.writeMem32(FLASH_BASE|FLASH_PEKEYR,PEKEY2); if(result<0) return result;

        // Read flash CR again to check FLASH_CR_LOCK if it's unlocked
        result = itrfApi.readMem32(FLASH_BASE|FLASH_PECR); if(result<0) return result;
        if( itrfApi.value32 & FLASH_PECR__PELOCK )
        {
            errorf("Error: can't unlock flash!\n");
            return -1;
        }

        // Unlock flash program
        result = itrfApi.writeMem32(FLASH_BASE|FLASH_PRGKEYR,PRGKEY1); if(result<0) return result;
        result = itrfApi.writeMem32(FLASH_BASE|FLASH_PRGKEYR,PRGKEY2); if(result<0) return result;

        // check pecr.prglock is cleared
        result = itrfApi.readMem32(FLASH_BASE|FLASH_PECR); if(result<0) return result;
        if( itrfApi.value32 & FLASH_PECR__PRGLOCK )
        {
            errorf("Error unlocking flash!\n");
            return -1;
        }
    }
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Erase sequence according ST user manual
//
function flash_erase(sector, address)
{
    local result;

    // Set the ERASE and PROG bits in the FLASH_PECR register to enable page erasing
    result = itrfApi.writeMem32(FLASH_BASE|FLASH_PECR, FLASH_PECR__ERASE|FLASH_PECR__PROG); if(result<0) return result;

    // Write a 32-bit word value in an address of the selected page to start the erase sequence
    result = itrfApi.writeMem32(address, 0 ); if(result<0) return result;

    //  Wait until the BSY bit is reset in the FLASH_SR register
    if(!checkBusy(1000))
	{
	   errorf("ERROR: Failed erasing sector %d\n", sector);
	   return -1;
	}

    //  Reset the ERASE bits in the FLASH_PECR register to disable the page erase
    return itrfApi.writeMem32(FLASH_BASE|FLASH_PECR, 0);
}



/////////////////////////////////////////////////////////////////////////////////
//
//  The length is always equals to the page to be programmed in bytes.
//  We don't use a flash loader here. We just write the pages word by word.
//  Because every word needs to be transported by USB, we don't check the busy
//  flag in between because we are not that fast.
//
function flash_write(sector, address, buffer)
{
    local result;

    // Adjust the probe speed to the maximum direct write
	if( savedProbeSpeed == 0)
	{
		local probeSpeed = itrfApi.getSpeed();
		if(probeSpeed > MAX_FLASH_SPEED )
		{
			savedProbeSpeed = probeSpeed;
			itrfApi.setSpeed(MAX_FLASH_SPEED);
		}
		else
		{
		    // We checked and don't changed the probe speed
			savedProbeSpeed = -1;
		}		
	}

    // Enable the program  FPRG and PRG in FLASH_PECR
    result = itrfApi.writeMem32( FLASH_BASE|FLASH_PECR, FLASH_PECR__FPRG |FLASH_PECR__PROG ); if(result<0) return result;

    // Do we have to use half page writes, is defined at upper device script 
    if(FLASH_HP)
	{
	    local halfPageSize = buffer.byteLength/2;
		result = itrfApi.writeMem(address, buffer, 0, halfPageSize ); if(result<0) return result;	
		if(!checkBusy(1000)) return -1;	
		result = itrfApi.writeMem(address+halfPageSize, buffer, halfPageSize, halfPageSize ); if(result<0) return result;
	
	}
	else
	{
		for(local count = 0; count < buffer.byteLength; count += 4)
		{
			itrfApi.writeMem32(address, buffer.un32(count) );
			address += 4;
		}
	}

    //  Wait until the BSY bit is reset in the FLASH_SR register
	if(!checkBusy(1000)) 
	{
	    errorf("ERROR: Failed writing sector %d\n", sector);
		return -1;
	}

    // Disable the program flag FPRG in FLASH_PECR
    return itrfApi.writeMem32(FLASH_BASE|FLASH_PECR, 0x00);
}

/////////////////////////////////////////////////////////////////////////////////
//
//
//
function flash_done()
{
    // Restore the original probe speed if changed
	if(savedProbeSpeed > 0)
		itrfApi.setSpeed(savedProbeSpeed);

    //  Locks the NVM by setting PELOCK in PECR
    local result = itrfApi.writeMem32(FLASH_BASE|FLASH_PECR, FLASH_PECR__PELOCK);
    if(result<0)
        return result;

    return 0;
}


/////////////////////////////////////////////////////////////////////////////////
//
//
//
function checkBusy(timeout)
{
    // Wait until the BSY bit is reset in the FLASH_SR register
	local time = GetTickCount();
    do{
	    if(GetTickCount() - time > timeout)
        {
            errorf("Error: flash keeps busy\n");
            return false;
        }	
        local result = itrfApi.readMem32(FLASH_BASE|FLASH_SR); 
		if(result<0) return result;
    }while ( itrfApi.value32 & FLASH_SR__BSY );


    // Check for errors
    if( itrfApi.value32 & (FLASH_SR__NOTZERO | FLASH_SR__SIZERR | FLASH_SR__PGAERR |  FLASH_SR__WRPERR) )
       return false;

    //  Check the EOP flag in the FLASH_SR register
    if( !(itrfApi.value32 & FLASH_SR__EOP) )
       return false;    

    return true;
}



